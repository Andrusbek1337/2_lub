# Лабороторная работа по дисциплине "Язык программирования C++"

# ЛАБОРАТОРНАЯ РАБОТА №2 STL

# Вариант: 7

# Группа: ИТ-5-2024

# ФИО: Шалашов Андрей юрьевич

# Описание лабораторной работы:

Решение всех задач оформить в виде функций, решающими поставленные задачи. В главной функции main организовать вызов всех функций с дружественным интерфейсом. Если исходные данные вводятся с клавиатуры, то организовать проверку на ввод.
В заданиях 1, 2, 3 элементами контейнеров являются целые числа. Для заполнения контейнера
использовать итератор и конструктор соответствующего контейнера, для вывода элементов
использовать итератор (для вывода элементов в обратном порядке использовать обратные
итераторы, возвращаемые функциями-членами rbegin и rend).
В задании 4 обработка данных выполняется без использования контейнеров. Если алгоритм требует применения функционального объекта, следует использовать лямбда-выражения. Использовать итераторы istream_iterator и ostream_iterator.
Если в заданиях 5, 6, 7, 8, 9, 10 тип элементов контейнера не указан, то предполагается, что
элементами являются целые числа.

# Задание 1. Заполнение и доступ к элементам. Обратные итераторы: Дан набор целых чисел. Заполнить список L исходными числами и вывести элементы списка L в начале в исходном, а затем в обратном порядке.

##### Поля (структуры данных):
    Контейнер: std::list<int> L - список целых чисел

##### Методы и функции
    Конструктор: используется для создания списка на основе вектора
    begin() / end() - итераторы для прямого обхода
    rbegin() / rend() - обратные итераторы для обхода в обратном порядке

##### Алгоритм решения
    Запросить у пользователя ввод набора целых чисел
    Создать список L, используя итераторы и конструктор копирования
    Вывести элементы списка в исходном порядке:
    Использовать итератор begin() для прохода от начала до конца
    Вывести элементы списка в обратном порядке:
    Использовать обратные итераторы rbegin() и rend()
    rbegin() указывает на последний элемент, rend() - на позицию перед первым

#### Тестирование
<img width="961" height="91" alt="image" src="https://github.com/user-attachments/assets/aeb95821-932b-4bae-bf4a-dc71821cfc9a" />
<img width="998" height="66" alt="image" src="https://github.com/user-attachments/assets/9beba84e-7db5-4c55-b0ad-91c9b7e4ef40" />

# Задание 2: Вставка элементов: Даны вектор V и дек D, имеющие четное количество элементов. Добавить в конец вектора первую половин у элементов дека (в исходном порядке), а в начало дека — вторую половину исходных элементов вектора (в обратном порядке). Использовать два вызова функции-члена insert.
##### Поля (структуры данных)
    Контейнер: std::vector<int> V - вектор целых чисел (четное количество элементов)
    Контейнер: std::deque<int> D - дек целых чисел (четное количество элементов)

##### Методы и функции
    size() - получение размера контейнера
    begin() / end() - итераторы
    insert() - вставка элементов в указанную позицию
    next() - продвижение итератора на заданное расстояние
    make_reverse_iterator() - создание обратного итератора

##### Алгоритм решения
    Получить от пользователя вектор V и дек D с четным количеством элементов
    Вычислить половины размеров контейнеров: half_d = D.size() / 2, half_v = V.size() / 2
    Добавить в конец вектора первую половину элементов дека (в исходном порядке):
    V.insert(V.end(), D.begin(), next(D.begin(), half_d))
    Добавить в начало дека вторую половину элементов вектора (в обратном порядке):
    Создать обратные итераторы для второй половины вектора
    D.insert(D.begin(), make_reverse_iterator(next(V.begin(), half_v)), make_reverse_iterator(V.begin()))
    Вывести оба контейнера после изменений

#### Тестирование
<img width="1443" height="257" alt="image" src="https://github.com/user-attachments/assets/03f23689-bb3a-46cc-a79d-8c4a05324a85" />

# Задание 3: Удаление элементов: Дан вектор V с нечетным количеством элементов N (≥5). Удалить три средних элемента вектора. Использовать один вызов функции-члена erase.
##### Поля (структуры данных)
    Контейнер: std::vector<int> V - вектор целых чисел (нечетное количество N ≥ 5)

##### Методы и функции
    size() - получение размера
    erase() - удаление диапазона элементов
    begin() - итератор на начало

##### Алгоритм решения
    Получить вектор с нечетным количеством элементов (N ≥ 5)
    Вычислить индекс первого из трех средних элементов: start = (N - 3) / 2
    Удалить три средних элемента одним вызовом erase:
    V.erase(V.begin() + start, V.begin() + start + 3)
    Вывести результирующий вектор

#### Тестирование

# Задание 4: Итераторы и алгоритмы: Даны вещественные числа A, D и целое число N. Вывести N первых членов арифметической прогрессии с первым элементом A и разностью D. Использовать алгоритм generate_n.
##### Поля (структуры данных)
    Переменные: double A - первый элемент, double D - разность, int N - количество
    Контейнер: std::vector<double> - для хранения членов прогрессии

##### Методы и функции
    generate_n() - алгоритм для генерации N элементов
    istream_iterator - итератор ввода
    ostream_iterator - итератор вывода
    Лямбда-функция - для вычисления следующего члена прогрессии

##### Алгоритм решения
    Запросить ввод A (первый элемент), D (разность) и N (количество)
    Создать вектор размером N
    Использовать generate_n с лямбда-функцией, которая:
    Захватывает по ссылке текущее значение
    Возвращает текущее значение и увеличивает его на D
    Вывести сгенерированную последовательность через ostream_iterator

# Задание 5: Алгоритмы поиска: Дан вектор V с четным количеством элементов. Добавить нулевой элемент перед последним элементом в первой половине вектора, совпадающим с каким-либо элементом из второй половины этого же вектора. Если вектор не содержит требуемых элементов, то не изменять его. Использовать алгоритм find_first_of и функцию-член insert.
##### Поля (структуры данных)
    Контейнер: std::vector<int> V - вектор целых чисел (четное количество)

##### Методы и функции
    find_first_of() - поиск первого элемента из первой половины, присутствующего во второй
    insert() - вставка элемента
    begin() / end() - итераторы

##### Алгоритм решения
    Получить вектор с четным количеством элементов
    Разделить вектор на две половины
    Применить find_first_of:
    Ищем в диапазоне [V.begin(), V.begin() + half)
    Любой элемент из диапазона [V.begin() + half, V.end())
    Если найден (итератор не равен first_half_end):
    Вставить 0 перед найденным элементом: V.insert(it, 0)
    Иначе - вектор не изменяется
    Вывести результат

# Задание 6: Базовые модифицирующие алгоритмы. Итераторы вставки: Дано число K (0 <K< 5) и список L, содержащий не менее 10 элементов. Набор из первых 5 элементов списка скопировать в конец списка, выполнив для этой копии циклический сдвиг на K позиций вправо, а набор из последних 5 элементов исходного списка скопировать в начало списка, выполнив для этой копии циклический сдвиг на K позиций влево. Использовать два вызова алгоритма rotate_copy и итераторы вставки, а также функцию advance. 
##### Поля (структуры данных)
    Контейнер: std::list<int> L - список целых чисел (≥ 10 элементов)
    Переменная: int K - величина сдвига (0 < K < 5)

##### Методы и функции
    rotate_copy() - копирование с циклическим сдвигом
    back_inserter / front_inserter - итераторы вставки
    advance() - продвижение итератора
    next() / prev() - получение следующего/предыдущего итератора

##### Алгоритм решения
    Получить список L (≥ 10 элементов) и число K (0 < K < 5)
    Извлечь первые 5 элементов в отдельный список first5
    Применить циклический сдвиг вправо на K к first5: rotate(first5.begin(), prev(first5.end(), K), first5.end())
    Скопировать результат в конец результирующего списка через back_inserter
    Извлечь последние 5 элементов в отдельный список last5 (с сохранением порядка)
    Применить циклический сдвиг влево на K к last5: rotate(last5.begin(), next(last5.begin(), K), last5.end())
    Скопировать результат в начало результирующего списка через front_inserter
    Скопировать оставшиеся элементы из середины исходного списка
    Вывести результат

# Задание 7: Сортировка и слияние: Дан вектор V с четным количеством элементов. Добавить в его конец первую половину элементов, которые содержал бы отсортированный по возрастанию вариант исходного вектора. Использовать функцию-член insert для увеличения количества элементов вектора на требуемую величину и алгоритм partial_sort_copy.
##### Поля (структуры данных)
    Контейнер: std::vector<int> V - вектор целых чисел (четное количество)

##### Методы и функции
    partial_sort_copy() - частичная сортировка с копированием
    insert() - вставка элементов

##### Алгоритм решения
    Получить вектор с четным количеством элементов
    Вычислить половину размера: half = V.size() / 2
    Создать вектор sorted_half размером half
    Применить partial_sort_copy:
    Исходный диапазон: весь вектор V
    Целевой диапазон: sorted_half
    В результате в sorted_half будет первая половина отсортированного вектора
    Вставить sorted_half в конец исходного вектора V
    Вывести результат

# Задание 8: Численные алгоритмы: Дан список L, элементами которого являются английские слова. Получить дек D со строковыми элементами, каждый из которых строится по паре соседних элементов исходного списка L следующим образом: последняя буква правого элемента пары приписывается справа к первой букве левого элемента пары. Количество элементов дека D должно быть на 1 меньше количества элементов списка L. Например, для исходного списка ABC, DEF, KLM, XYZ полученный дек должен содержать строки AF, DM, KZ. Использовать алгоритм adjacent_difference с итератором вставки и функциональным объектом, а также функцию-член erase для дека D.
##### Поля (структуры данных)
    Контейнер: std::list<std::string> L - список английских слов
    Контейнер: std::deque<std::string> D - дек для результата

##### Методы и функции
    adjacent_difference() - алгоритм для обработки соседних элементов
    back_inserter - итератор вставки
    erase() - удаление элемента
    Лямбда-функция - функциональный объект для формирования строк

##### Алгоритм решения
    Получить список английских слов (минимум 2 элемента)
    Создать дек D и добавить заглушку (пустую строку) для adjacent_difference
    Применить adjacent_difference с лямбда-функцией:
    Лямбда принимает два соседних элемента left и right
    Формирует строку: первый символ left + последний символ right
    Результат добавляется в дек через back_inserter
    Удалить первый элемент дека (заглушку): D.erase(D.begin())
    Вывести результат

# Задание 9: Множества: Дан вектор V0, целое число N (> 0) и набор векторов V1, …, VN. Известно, что размер вектора V0 не превосходит размера любого из векторов V1, …, VN. Найти количество векторов VI, I = 1, …, N, в которых содержатся все элементы вектора V0 (с учетом их повторений). Использовать алгоритм includes, применяя его в цикле к двум мультимножествам (контейнерам типа multiset), одно из которых создано на основе вектора V0, а другое на очередной итерации содержит элементы очередного из векторов VI, I = 1, …, N.
##### Поля (структуры данных)
    Контейнер: std::vector<int> V0 - исходный вектор
    Контейнер: std::vector<int> V1...VN - набор векторов для проверки
    Контейнер: std::multiset<int> - мультимножества для каждого вектора

##### Методы и функции
    includes() - проверка включения одного множества в другое
    multiset - контейнер, сохраняющий кратные вхождения

##### Алгоритм решения
    Получить вектор V0 и число N (> 0)
    Создать мультимножество ms0 из V0 (сохраняет повторения)
    Для каждого i от 1 до N:
    Получить вектор Vi
    Создать мультимножество ms из Vi
    Проверить includes(ms.begin(), ms.end(), ms0.begin(), ms0.end())
    Если true - увеличить счетчик
    Вывести количество подходящих векторов

# Задание 10: Отображения: Дан вектор V. Выполнить группировку элементов вектора V, используя в качестве ключа группировки последнюю (т. е. правую) цифру элемента: в одну группу должны входить все элементы вектора V, оканчивающиеся на одну и ту же цифру (сгруппированные элементы должны располагаться в том же порядке, в котором они располагались в исходном векторе). Представить результат группировки в виде мульти отображения M (класса multimap), ключами которого являются ключи группировки, т. е. последние цифры элементов вектора V, а значениями — элементы вектора, оканчивающиеся на соответствующую цифру (таким образом, отображение M должно иметь тип multimap<int, int>). Вывести полученное отображение (для каждого элемента отображения M вначале выводить ключ, а затем связанный с ним элемент вектора V; ключи могут повторяться). Для перебора элементов контейнеров использовать циклы с параметрами-итераторами.
##### Поля (структуры данных)
    Контейнер: std::vector<int> V - исходный вектор
    Контейнер: std::multimap<int, int> M - мультиотображение для группировки

##### Методы и функции
    multimap - ассоциативный контейнер с возможностью повторяющихся ключей
    insert() - вставка пары ключ-значение
    begin() / end() - итераторы для обхода

##### Алгоритм решения
    Получить вектор V
    Для каждого элемента вектора:
    Вычислить ключ = последняя цифра числа: abs(val) % 10
    Вставить пару {key, val} в мультиотображение M
    Вывести содержимое M:
    Для каждой пары вывести ключ и значение
    Ключи могут повторяться (группы элементов с одинаковой последней цифрой)
    Элементы в каждой группе располагаются в порядке исходного вектора
